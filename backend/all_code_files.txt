from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin, Group, Permission
from django.db import models
import uuid

from django.conf import settings


# other imports
from rest_framework.authtoken.models import Token
import binascii
import os

class CustomToken(Token):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        related_name='custom_auth_token',
        on_delete=models.CASCADE
    )

    objects = models.Manager()  

    def save(self, *args, **kwargs):
        if not self.key:
            self.key = self.generate_key()
        return super().save(*args, **kwargs)

    def generate_key(self):
        return binascii.hexlify(os.urandom(20)).decode()

ROLE_CHOICES = (
    ("student", "Student"),
    ("admin", "Admin"),
    ("mentor", "Mentor"),
)

class UserManager(BaseUserManager):
    def create_user(self, email, name, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        email = self.normalize_email(email)

        # extra_fields.setdefault("username", "")

        user = self.model(email=email, name=name, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, name, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        # extra_fields.setdefault("username", "")

        return self.create_user(email=email, name=name, password=password, **extra_fields)


class User(AbstractBaseUser, PermissionsMixin):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    
    username = None  

    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default="student")
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    groups = models.ManyToManyField(Group, related_name="custom_user_groups", blank=True)
    user_permissions = models.ManyToManyField(Permission, related_name="custom_user_permissions", blank=True)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["name"]

    objects = UserManager()

    def __str__(self):
        return f"{self.name} ({self.role})"from django.contrib.auth import authenticate, get_user_model
from users.models import CustomToken as Token,User
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from courses.models import UserCourse
from courses.serializers import UserCourseSerializer
from rest_framework.permissions import AllowAny
from rest_framework import status


User = get_user_model()







@api_view(["GET"])
@permission_classes([IsAuthenticated])
def user_profile(request):
    """Returns the profile data of the authenticated user."""
    user = request.user

    # Fetch user data
    completed_courses = list(user.enrollments.filter(status='completed').values_list('course__title', flat=True))
    enrolled_courses = list(user.enrollments.values_list('course__title', flat=True))

    return Response({
        "user": {
            "id": str(user.id),
            "name": user.name,
            "email": user.email,
        },
        "completed_courses": completed_courses,
        "enrolled_courses": enrolled_courses
    })
@api_view(["POST"])
@permission_classes([AllowAny])
def register_user(request):
    """Handles user registration"""
    try:
        # Directly access data from request.data (parsed by DRF)
        name = request.data.get("name")
        email = request.data.get("email")
        password = request.data.get("password")

        if not name or not email or not password:
            return Response({"error": "Missing required fields"}, status=status.HTTP_400_BAD_REQUEST)

        if User.objects.filter(email=email).exists():
            return Response({"error": "Email already exists"}, status=status.HTTP_400_BAD_REQUEST)

        user = User.objects.create_user(email=email, name=name, password=password)
        token, _ = Token.objects.get_or_create(user=user)

        return Response({"token": token.key, "user_id": str(user.id)}, status=status.HTTP_201_CREATED)

    except Exception as e:
        import traceback
        traceback.print_exc()
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(["POST"])
@permission_classes([AllowAny])
def login_user(request):
    """Handles user login"""
    email = request.data.get("email")
    password = request.data.get("password")

    user = authenticate(email=email, password=password)

    if user:
        token, _ = Token.objects.get_or_create(user=user)
        return Response({"token": token.key, "user_id": str(user.id)}, status=status.HTTP_200_OK)

    return Response({"error": "Invalid credentials"}, status=status.HTTP_401_UNAUTHORIZED)


@api_view(["POST"])
def reset_password(request):
    """Reset password for a user using email and new password"""
    email = request.data.get("email")
    new_password = request.data.get("new_password")

    if not email or not new_password:
        return Response({"error": "Email and new password are required."}, status=400)

    try:
        user = User.objects.get(email=email)
        user.set_password(new_password)
        user.save()
        return Response({"message": "Password updated successfully!"}, status=200)
    except User.DoesNotExist:
        return Response({"error": "User not found."}, status=404)from django.urls import path
from .views import register_user, login_user,reset_password, user_profile

urlpatterns = [
    path("register/", register_user, name="register"),
    path("login/", login_user, name="login"),
    path("profile/", user_profile, name="user_profile"), 
    path("reset-password/", reset_password, name="reset_password"),  
]from rest_framework.authentication import TokenAuthentication
from users.models import CustomToken



class CustomTokenAuthentication(TokenAuthentication):
    model = CustomTokenfrom .models import Course, UserCourse
from .serializers import CourseSerializer, UserCourseSerializer

from rest_framework.response import Response
from rest_framework import status
from .models import Course, UserCourse
from rest_framework.decorators import api_view, permission_classes, authentication_classes
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import IsAuthenticated
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from rest_framework.permissions import AllowAny
from rest_framework.views import APIView
from rest_framework import status
from .models import UserCourse
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt


@method_decorator(csrf_exempt, name='dispatch') 
class EnrollInCourseView(APIView):
    authentication_classes = [TokenAuthentication] 
    permission_classes = [IsAuthenticated]

    def post(self, request, course_id):
        user = request.user
        if UserCourse.objects.filter(user=user, course_id=course_id).exists():
            return Response({"message": "Already enrolled."}, status=status.HTTP_200_OK)
        UserCourse.objects.create(user=user, course_id=course_id)
        return Response({"message": "Enrolled successfully."}, status=status.HTTP_201_CREATED)

@api_view(["GET"])
@permission_classes([AllowAny])
def get_courses(request):
    """Fetch all courses."""
    courses = Course.objects.all()
    serializer = CourseSerializer(courses, many=True)
    return Response(serializer.data)
@api_view(["GET"])
def get_course_detail(request, course_id):
    """Fetch a specific course along with its modules."""
    try:
        course = Course.objects.get(id=course_id)
        serializer = CourseSerializer(course)
        return Response(serializer.data)
    except Course.DoesNotExist:
        return Response({"error": "Course not found"}, status=404)

@api_view(["GET"])
def get_user_reviews(request, course_id):
    """Fetch user reviews for a specific course."""
    user_courses = UserCourse.objects.filter(course__id=course_id)
    serializer = UserCourseSerializer(user_courses, many=True)
    return Response(serializer.data)


@api_view(["GET"])
@permission_classes([IsAuthenticated])
def get_enrolled_courses(request):
    enrollments = UserCourse.objects.filter(user=request.user)
    data = [{"id": uc.course.id} for uc in enrollments]
    return Response(data)from django.urls import path
from .views import (
    EnrollInCourseView,
    get_courses,
    get_course_detail,
    get_user_reviews,
    get_enrolled_courses,
)

urlpatterns = [
    path("", get_courses, name="get_courses"),
    path("<uuid:course_id>/", get_course_detail, name="get_course_detail"),
    path("<uuid:course_id>/reviews/", get_user_reviews, name="get_user_reviews"),
    path("<uuid:course_id>/enroll/", EnrollInCourseView.as_view(), name="enroll_course"),
    path("enrolled-courses/", get_enrolled_courses, name="get_enrolled_courses"),
]import uuid
from django.db import models

from users.models import User



def course_image_path(instance, filename):
    """Generate file path for new course image upload."""
    return f'courses/{instance.id}/{filename}'

class Course(models.Model):
    id = models.UUIDField(default=uuid.uuid4, primary_key=True, editable=False)
    title = models.CharField(max_length=255)
    description = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.ForeignKey(User, on_delete=models.CASCADE)
    image = models.ImageField(upload_to=course_image_path, null=True, blank=True)

    def __str__(self):
        return self.title


class Module(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name="modules")
    title = models.CharField(max_length=255)
    content = models.TextField()
    order_no = models.PositiveIntegerField()

    def __str__(self):
        return f"{self.title} (Course: {self.course.title})"


class UserCourse(models.Model):
    STATUS_CHOICES = (
        ("in-progress", "In Progress"),
        ("completed", "Completed"),
    )

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="enrollments")
    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name="user_courses")
    enrolled_at = models.DateTimeField(auto_now_add=True)
    progress_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=0.00)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="in-progress")

    def __str__(self):
        return f"{self.user.name} -> {self.course.title} ({self.status})"from rest_framework import serializers
from .models import Course, Module, UserCourse
from users.models import User  # Assuming the User model exists

class ModuleSerializer(serializers.ModelSerializer):
    """Serializes course modules (sections & lessons)."""

    class Meta:
        model = Module
        fields = ["id", "title", "content", "order_no"]

class CourseSerializer(serializers.ModelSerializer):
    image = serializers.ImageField(required=False)

    class Meta:
        model = Course
        fields = ['id', 'title', 'description', 'created_at', 'created_by', 'image']

class UserCourseSerializer(serializers.ModelSerializer):
    """Serializes user enrollment and progress."""
    
    course = CourseSerializer()

    class Meta:
        model = UserCourse
        fields = ["id", "user", "course", "progress_percentage", "status", "enrolled_at"]

class ReviewSerializer(serializers.ModelSerializer):
    """Serializes user reviews (Assuming review model exists)."""

    user = serializers.StringRelatedField()  # To show the reviewer's name

    class Meta:
        model = UserCourse  # Replace with Review model if available
        fields = ["user", "progress_percentage", "status", "enrolled_at"]